import core.runtime

namespace core
{
    public interface ISizeable
    {
        // size is readonly
        func size -> int { readonly get }
    }

    public interface IArray<T, TIterator> extends ISizeable //, MutableIterable<T, int>
    {
        /// ref indexer #2, not readonly
        func operator [index: int] -> ref T 
            requires index >= 0 && index < size
        { 
            get 
        }

        // in indexer #3, readonly
        func operator [index: int] -> in T
            requires index >= 0 && index < size
        {            
            readonly get 
        }
    }

    /// Base interface for iterable items
    public interface Iterable<T, TIterator>
    {
        /// Starts the iterator
        readonly func iterate_begin() -> TIterator

        /// Returns true if the iterable has remaining elements
        readonly func iterate_has_next(iterator: ref TIterator) -> bool 

        /// Returns the next element
        readonly func iterate_next(iterator: ref TIterator) -> T

        /// Ends the iterator
        readonly func iterate_end(iterator: ref TIterator)
    }

    /// Base interface for mutable iterable items
    public interface MutableIterable<T, TIterator> extends Iterable<T, TIterator>
    {
        /// Returns a reference to the next element (mutable)
        func iterate_next(iterator: ref TIterator) -> ref T
    }

    /// Example of a Range struct
    public struct Range implements Iterable<int, int>
    {
        private let _from : int
        private let _to : int

        public constructor(indexFrom: int, indexTo: int)
        {
            _from = indexFrom
            _to = indexTo
        }

        readonly func Iterable<int, int>.iterate_begin() -> int => _from

        readonly func Iterable<int, int>.iterate_has_next(index: ref int) -> bool => index <= _to

        readonly func Iterable<int, int>.iterate_next(index: ref int) -> int => index++

        readonly func Iterable<int, int>.iterate_end(state: ref int) {}
    }

    /// Example using Range
    public module enumeration_playground
    {
        public static func sun_range(range: Range) -> int
        {
            var result : int = 141
            for x in range {
                result += x
            }
            return result
        }
    }
    

    public abstract class Array implements ISizeable
    {
        private let _size : int
        private var _firstElement : int

        protected constructor() {}

        // size is readonly
        public func size -> int { readonly get => _size }
    }

    public class Array<T> extends Array implements IArray<T, []T>
    {
        // The array cannot be initialized by using directly this class
        private constructor() {}

        /// ref indexer #2, not readonly
        public extern func operator [index: int] -> ref T { 
            @Intrinsic
            get 
        }

        // in indexer #3, readonly
        public extern func operator [index: int] -> in T {
            @Intrinsic
            get 
        }

        // readonly func Iterable<T, int>.iterate_begin() -> int => -1

        // @FuncImpl(FuncImplOptions.AGGRESSIVE_INLINING)
        // readonly func Iterable<T, int>.iterate_next(index: ref int) -> bool {
        //     var nextIndex = index + 1
        //     if nextIndex < size then {
        //         index = nextIndex
        //         return true   
        //     }
        //     return false
        // }

        // func Iterable<T, int>.iterate_item(index: ref int) -> T => this[index] 

        // func MutableIterable<T, int>.iterate_item(index: ref int) -> ref T => ref this[index] 

        // readonly func Iterable<T, int>.iterate_end(state: ref int) {}
    }

    // public module array_playground
    // {
    //     // Constant
    //     public const static_readonly_array : []int = new [size]int :: index => index * 2

    //     // Returns a readonly array
    //     public static func get_readonly_array(size: int) -> readonly []int
    //         requires size > 0
    //     {
    //         // store array[i] = i * 2
    //         return new [size]int :: index => index * 2
    //     }

    //     // Returns a readonly array of readonly elements
    //     public static func get_readonly_array(size: int) -> readonly [] readonly MyObject
    //         requires size > 0
    //     {
    //         return new [size] MyObject :: index => new MyObject(index)
    //     }
    // }

/*
    public struct Slice<T> implements IArray<T>
    {
        private let _array : Array<T>
        private let _offset : int
        private let _size : int

        public constructor(array: Array<T>, offset: int, size: int)
        {
            _array = array
            _offset = offset
            _size = size
        }

        public func size -> int { readonly get => _size }

        /// indexer #1: regular indexer, readonly get
        public func operator [index: int] -> T { 
            readonly get => _array[index]
            set {
                _array[index] = value
            }
        }

        /// ref indexer #2, not readonly
        public func operator [index: int] -> ref T { 
            get => ref _array[index]
        }

        // in indexer #3, readonly
        public func operator [index: int] -> in T { 
            readonly get => in _array[index]
        }
    }
*/
}

