import core.runtime

namespace core
{
    public interface ISizeable
    {
        // size is readonly
        func size -> int { readonly get }
    }

    public interface IArray<T> extends ISizeable, MutableIterable<T, int>
    {
        /// ref indexer #2, not readonly
        func operator [index: int] -> ref T 
            requires index >= 0 && index < size
        { 
            get 
        }

        // // in indexer #3, readonly
        // func operator [index: int] -> in T
        //     requires index >= 0 && index < size
        // {            
        //     readonly get 
        // }
    }

    /// Base interface for iterable items
    public interface Iterable<T, TIterator>
    {
        /// Starts the iterator
        readonly func iterate_begin() -> TIterator

        /// Returns true if the iterable has a current element
        readonly func iterate_has_current(iterator: ref TIterator) -> bool 

        /// Returns the current element
        readonly func iterate_current(iterator: ref TIterator) -> T

        /// Moves the iterator to the next element
        readonly func iterate_next(iterator: ref TIterator)

        /// Ends the iterator
        readonly func iterate_end(iterator: ref TIterator)
    }

    /// Base interface for mutable iterable items
    public interface MutableIterable<T, TIterator> extends Iterable<T, TIterator>
    {
        /// Returns a reference to the next element (mutable)
        func iterate_current(iterator: ref TIterator) -> ref T
    }

    public module enumeration_playground
    {
        /*

        /// A yield method: declared with a return type `yield int as XXX`, where XXX is a synthesized type
        /// Here YieldRange is a synthesized struct type
        public static func yield_range(range: Range) -> yield int as YieldRange
        {
            for item in range {
                yield item
            }
        }

        /// Will synthesized the YieldRange struct type
        public static func test_yield(range: Range)
        {
            var result : int = 141
            // Effectively using YieldRange behind the scene
            for x in yield_range(range) { 
                result += x
            }
            return result
        }
        */
    }
    

    public abstract class Array implements ISizeable
    {
        private let _size : int
        private var _firstElement : int

        private protected constructor() {}

        // size is readonly
        public func size -> int { readonly get => _size }
    }

    public class Array<T> extends Array implements IArray<T>
    {
        // The array cannot be initialized by using directly this class
        private constructor() {}

        /// ref indexer #2, not readonly
        public extern func operator [index: int] -> ref T { 
            @Intrinsic
            get 
        }

        // // in indexer #3, readonly
        // public extern func operator [index: int] -> in T {
        //     @Intrinsic
        //     get 
        // }

        readonly func Iterable<T, int>.iterate_begin() -> int => 0

        readonly func Iterable<T, int>.iterate_has_current(index: ref int) -> bool => index < size

        readonly func Iterable<T, int>.iterate_current(index: ref int) -> T => this[index]

        func MutableIterable<T, int>.iterate_current(index: ref int) -> ref T => ref this[index]

        readonly func Iterable<T, int>.iterate_next(index: ref int) => index++

        readonly func Iterable<T, int>.iterate_end(state: ref int) {}

        // readonly func Iterable<T, int>.iterate_begin() -> int => -1

        // @FuncImpl(FuncImplOptions.AGGRESSIVE_INLINING)
        // readonly func Iterable<T, int>.iterate_next(index: ref int) -> bool {
        //     var nextIndex = index + 1
        //     if nextIndex < size then {
        //         index = nextIndex
        //         return true   
        //     }
        //     return false
        // }

        // func Iterable<T, int>.iterate_item(index: ref int) -> T => this[index] 

        // func MutableIterable<T, int>.iterate_item(index: ref int) -> ref T => ref this[index] 

        // readonly func Iterable<T, int>.iterate_end(state: ref int) {}
    }

    public module array_playground
    {
        static func get_new_array_with_initializer() -> []u8
        {
            return new []u8 { 1, 2, 3, 4}
        }

        static func get_new_array_with_size_and_initializer() -> []u8
        {
            return new [4]u8 { 1, 2, 3, 4}
        }

        static func get_array_element_int(array: []u8) -> u8
        {
            return array[0]
        }

        static func get_array_element_int(array: []u8, index: int) -> u8
        {
            return array[index]
        }

        static func get_array_class_element_int(array: Array<u8>) -> u8
        {
            return array[0]
        }

        static func get_array_class_element_int(array: Array<u8>, index: int) -> u8
        {
            return array[index]
        }

        static func get_array_to_array_class(array: []u8) -> Array<u8> => array

        static func get_array_class_to_array(array: Array<u8>) -> []u8 => array

    }

    // public module array_playground
    // {
    //     // Constant
    //     public const static_readonly_array : []int = new [size]int :: index => index * 2

    //     // Returns a readonly array
    //     public static func get_readonly_array(size: int) -> readonly []int
    //         requires size > 0
    //     {
    //         // store array[i] = i * 2
    //         return new [size]int :: index => index * 2
    //     }

    //     // Returns a readonly array of readonly elements
    //     public static func get_readonly_array(size: int) -> readonly [] readonly MyObject
    //         requires size > 0
    //     {
    //         return new [size] MyObject :: index => new MyObject(index)
    //     }
    // }

/*
    public struct Slice<T> implements IArray<T>
    {
        private let _array : Array<T>
        private let _offset : int
        private let _size : int

        public constructor(array: Array<T>, offset: int, size: int)
        {
            _array = array
            _offset = offset
            _size = size
        }

        public func size -> int { readonly get => _size }

        /// indexer #1: regular indexer, readonly get
        public func operator [index: int] -> T { 
            readonly get => _array[index]
            set {
                _array[index] = value
            }
        }

        /// ref indexer #2, not readonly
        public func operator [index: int] -> ref T { 
            get => ref _array[index]
        }

        // in indexer #3, readonly
        public func operator [index: int] -> in T { 
            readonly get => in _array[index]
        }
    }
*/
}

