namespace core
public immutable struct Range implements Iterable<int, Range.Iterator>
{
    public constructor(begin: Index, end: Index)
    {
        this.begin = begin
        this.end = end
    }

    public let begin : Index

    public let end : Index

    readable func Iterable<int, Iterator>.iterate_begin() -> Iterator =>
        if begin.value > end.value then 
            new Iterator(begin.value, end.value, begin.value, 1)
        else 
            new Iterator(end.value, begin.value, begin.value, -1)

    readable func Iterable<int, Iterator>.iterate_has_current(iterator: ref Iterator) -> bool => iterator.index >= iterator.min && iterator.index <= iterator.max

    readable func Iterable<int, Iterator>.iterate_current(iterator: ref Iterator) -> int => iterator.index

    readable func Iterable<int, Iterator>.iterate_next(iterator: ref Iterator) => iterator.move()

    readable func Iterable<int, Iterator>.iterate_end(iterator: ref Iterator) {}

    public struct Iterator
    {
        private var _index: int

        public constructor(min: int, max: int, index: int, direction: int) requires min <= max
        {
            this.min = min
            this.max = max
            _index = index
            this.direction = direction
        }

        public let min: int

        public let max: int

        public let direction: int

        public func index -> int => _index

        public func move() => _index += direction
    }
}

public module range_playground
{
    public static func sun_range() -> int
    {
        var result : int = 142
        for x in 0..^0 {
            result += x
        }
        return result
    }

    public static func sun_range(range: Range) -> int
    {
        var result : int = 141
        for x in range {
            result += x
        }
        return result
    }

    public static func sun_range(array: []u8) -> int
    {
        var result : int = 0
        for i in 0..<array.size {
            result += array[i]
        }
        return result
    }
}