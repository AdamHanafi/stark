import core.runtime

namespace core.sync
{
    public enum MemoryOrder
    {
        SEQUENTIAL_CONSISTENT
        RELAXED
        CONSUME
        ACQUIRE
        RELEASE
        ACQUIRE_RELEASE        
    }


    public interface IOption<T>
    {
        func has_value -> bool { readonly get }

        func value -> T { readonly get } 
    }

    public module atomic
    {

        @FuncImpl(FuncImplOptions.INTERNAL_CALL)
        @Intrinsic
        public extern static func load(data: ref int, 
                                       order: MemoryOrder = MemoryOrder.SEQUENTIAL_CONSISTENT) -> int

        @FuncImpl(FuncImplOptions.INTERNAL_CALL)
        @Intrinsic
        public extern static func store(data: ref int, 
                                        value_to_store: int, 
                                        order: MemoryOrder = MemoryOrder.SEQUENTIAL_CONSISTENT)

        @FuncImpl(FuncImplOptions.INTERNAL_CALL)
        @Intrinsic
        public extern static func exchange(data: ref int, 
                                           value_to_exchange: int, 
                                           order: MemoryOrder = MemoryOrder.SEQUENTIAL_CONSISTENT) -> int

        @FuncImpl(FuncImplOptions.INTERNAL_CALL)
        @Intrinsic
        public extern static func compare_exchange(data: ref int, 
                                                   value_to_exchange: int, 
                                                   value_to_compare: int, 
                                                   order: MemoryOrder = MemoryOrder.SEQUENTIAL_CONSISTENT) -> bool

        // TODO: add for all primitives:
        // i8, i16, i32, i64
        // u8, u16, u32, u64
        // object
    }
}
